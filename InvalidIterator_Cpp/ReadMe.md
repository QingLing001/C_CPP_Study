一、容器概述
(1) vector
内部数据结构：数组。
随机访问每个元素，所需要的时间为常量。
在末尾增加或删除元素所需时间与元素数目无关，在中间或开头增加或删除元素所需时间随元素数目呈线性变化。
可动态增加或减少元素，内存管理自动完成，但程序员可以使用reserve()成员函数来管理内存。
vector的迭代器在内存重新分配时将失效（它所指向的元素在该操作的前后不再相同）。当把超过capacity()-size()个元素插入vector中时，内存会重新分配，所有的迭代器都将失效；否则，指向当前元素以后的任何元素的迭代器都将失效。当删除元素时，指向被删除元素以后的任何元素的迭代器都将失效。

(2)deque
deque由于内部结构的复杂，迭代器失效的场景也会有些复杂。
随机访问每个元素，所需要的时间为常量。
在开头和末尾增加元素所需时间与元素数目无关，在中间增加或删除元素所需时间随元素数目呈线性变化。
可动态增加或减少元素，内存管理自动完成，不提供用于内存管理的成员函数。

插入（基本可以认为任何Insert都会失效）：
在队首或队尾插入元素，所有元素的迭代器都将失效，引用仍然有效。这点不太好理解，查阅了网上很多解释，有一种说法比较合理：
在队首或队尾插入元素，数据块里的其他元素不会发生挪动，所以其他元素的地址不变，引用仍然有效。但是如果插入时数据块已满，那么就要重新申请数据块。有了新的数据块，那当然也要新加一个指针指向它，并添加到数据块指针数组。而数据块指针数组也是有最大容量的，如果这个数组已达到最大容量，那么就会回到vector达到最大容量时的场景，重新申请一块更大的内存，把老的指针全部拷贝到新的内存里。那么显然，所有元素的迭代器里存放的数据块指针还指向老的非法地址，迭代器也就变成失效了。
在中间位置插入元素，所有元素的迭代器和引用都将失效。这个应该是所有元素挪动引起的。
删除：
删除队首或队尾元素，除被删的元素外，其他元素的迭代器和引用都依然有效；
删除中间元素，所有元素的迭代器和引用都将失效。

(3)list
内部数据结构：双向环状链表。
不能随机访问一个元素。
可双向遍历。
在开头、末尾和中间任何地方增加或删除元素所需时间都为常量。
可动态增加或减少元素，内存管理自动完成。
增加任何元素都不会使迭代器失效。删除元素时，除了指向当前被删除元素的迭代器外，其它迭代器都不会失效。

(4)slist
内部数据结构：单向链表。
不可双向遍历，只能从前到后地遍历。
其它的特性同list相似。

(5)stack
适配器，它可以将任意类型的序列容器转换为一个堆栈，一般使用deque作为支持的序列容器。
元素只能后进先出（LIFO）。
不能遍历整个stack。

(6)queue
适配器，它可以将任意类型的序列容器转换为一个队列，一般使用deque作为支持的序列容器。
元素只能先进先出（FIFO）。
不能遍历整个queue。

(7)priority_queue
适配器，它可以将任意类型的序列容器转换为一个优先级队列，一般使用vector作为底层存储方式。
只能访问第一个元素，不能遍历整个priority_queue。
第一个元素始终是优先级最高的一个元素。

(8)set/multiset,map/multimap 底层为红黑树
如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效。

(10)hash_set/hash_multiset,hash_map/hash_multimap，unordered_set/unordered_map
与红黑树版相比较，它里面的元素不一定是经过排序的，而是按照所用的hash函数分派的，它能提供更快的搜索速度（当然跟hash函数有关）。
insert：如果插入元素后，容器的大小超过了它的最大容量，就会触发rehash，导致所有元素的迭代器失效，但是引用依然有效。
erase：除被删的元素外，其他元素的迭代器依然有效。

二、删除操作：
    1.对于序列式容器(如vector,deque)，删除当前的iterator会使当前及之后所有元素的iterator都失效。这是因为vetor,deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。所以不能使用erase(iter++)的方式。
    代码正确写法为：
    for( iter = c.begin(); iter != c.end(); )
        iter = c.erase(iter);
    备注：如果删除的当前迭代器不是最后一个位置，且最后当前迭代器未越界，有可能不会报错，会形成隐藏bug，千万注意。

    2.对于关联容器(如map, set,multimap,multiset)，删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响。erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。
    代码正确写法为:
    for( iter = c.begin(); iter != c.end(); ) 
        c.erase(iter++);
        //iter = c.erase(iter) //C++11后也可以用

    3.对于链表式容器(如list)，删除当前的iterator，仅仅会使当前的iterator失效，这是因为list之类的容器，使用了链表来实现，插入、删除一个结点不会对其他结点造成影响。只要在erase时，递增当前iterator即可，并且erase方法可以返回下一个有效的iterator。
    代码正确写法：
    for (iter = list.begin(); it != list.end();)
    {
    if (...)
        //list.erase(iter++); //方法1
        iter = list.erase(iter);//方法2  //erase删除元素，返回下一个迭代器
    else
        ++iter;
    }
    4.unordered_set/unordered_map除被删的元素外，其他元素的迭代器依然有效。
    解决：使用erase返回值

三、插入操作
    1.vector进行插入时,可能会因为扩容而导致传入的值失效，解决，使用insert返回的iterator.
    2.deque进行插入操作时，大概率会引起迭代器失效。解决，使用insert返回的iterator.
    3.unordered_set/unordered_map 可能会因为扩容rehash引起迭代器失效，但是引用依然有效。

四、总结
    1.迭代器失效的含义：该迭代器iter不能参与任何运算，包括iter++,*ite等。
    2.迭代器失效的种类：当前迭代器、当前之后之后的迭代器、所有迭代器
    3.erase(iter)，当前iter一定失效。
    2.总体来说，凡是insert、erase操作，都要小心使用，都有可能存在迭代器失效的场景。
    